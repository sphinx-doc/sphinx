from __future__ import annotations

from collections.abc import Callable
from typing import TYPE_CHECKING

from docutils import nodes
from docutils.statemachine import StringList

from sphinx.ext.autodoc._directive_options import (
    _AutoDocumenterOptions,
    _process_documenter_options,
)
from sphinx.util import logging
from sphinx.util.docutils import SphinxDirective, switch_source_input
from sphinx.util.parsing import nested_parse_to_nodes

if TYPE_CHECKING:
    from typing import Any

    from docutils.nodes import Node
    from docutils.parsers.rst.states import RSTState
    from docutils.utils import Reporter

    from sphinx.config import Config
    from sphinx.environment import BuildEnvironment
    from sphinx.ext.autodoc import Documenter
    from sphinx.ext.autodoc._directive_options import Options

logger = logging.getLogger(__name__)


class DummyOptionSpec(dict[str, Callable[[str], str]]):  # NoQA: FURB189
    """An option_spec allows any options."""

    def __bool__(self) -> bool:
        """Behaves like some options are defined."""
        return True

    def __getitem__(self, _key: str) -> Callable[[str], str]:
        return lambda x: x


class DocumenterBridge:
    """A parameters container for Documenters."""

    def __init__(
        self,
        env: BuildEnvironment,
        reporter: Reporter | None,
        options: _AutoDocumenterOptions,
        lineno: int,
        state: Any,
    ) -> None:
        self.env = env
        self._reporter = reporter
        self.genopt = options
        self.lineno = lineno
        self.record_dependencies: set[str] = set()
        self.result = StringList()
        self.state = state


def process_documenter_options(
    documenter: type[Documenter], config: Config, options: dict[str, str | None]
) -> Options:
    from sphinx.ext.autodoc._directive_options import Options

    opts = _process_documenter_options(
        option_spec=documenter.option_spec,
        default_options=config.autodoc_default_options,
        options=options,
    )
    return Options(opts)


def parse_generated_content(
    state: RSTState, content: StringList, documenter: Documenter
) -> list[Node]:
    """Parse an item of content generated by Documenter."""
    with switch_source_input(state, content):
        if documenter.titles_allowed:
            return nested_parse_to_nodes(state, content)

        node = nodes.paragraph()
        # necessary so that the child nodes get the right source/line set
        node.document = state.document
        state.nested_parse(content, 0, node, match_titles=False)
        return node.children


class AutodocDirective(SphinxDirective):
    """A directive class for all autodoc directives. It works as a dispatcher of Documenters.

    It invokes a Documenter upon running. After the processing, it parses and returns
    the content generated by Documenter.
    """

    option_spec = DummyOptionSpec()
    has_content = True
    required_arguments = 1
    optional_arguments = 0
    final_argument_whitespace = True

    def run(self) -> list[Node]:
        reporter = self.state.document.reporter

        try:
            source, lineno = reporter.get_source_and_line(  # type: ignore[attr-defined]
                self.lineno
            )
        except AttributeError:
            source, lineno = (None, None)
        logger.debug('[autodoc] %s:%s: input:\n%s', source, lineno, self.block_text)

        # look up target Documenter
        objtype = self.name[4:]  # strip prefix (auto-).
        doccls = self.env._registry.documenters[objtype]

        # process the options with the selected documenter's option_spec
        try:
            opts = _process_documenter_options(
                option_spec=doccls.option_spec,
                default_options=self.config.autodoc_default_options,
                options=self.options,
            )
            documenter_options = _AutoDocumenterOptions.from_directive_options(opts)
        except (KeyError, ValueError, TypeError) as exc:
            # an option is either unknown or has a wrong type
            logger.error(  # NoQA: TRY400
                'An option to %s is either unknown or has an invalid value: %s',
                self.name,
                exc,
                location=(self.env.current_document.docname, lineno),
            )
            return []

        # generate the output
        params = DocumenterBridge(
            self.env, reporter, documenter_options, lineno, self.state
        )
        documenter = doccls(params, self.arguments[0])
        documenter.generate(more_content=self.content)
        if not params.result:
            return []

        logger.debug('[autodoc] output:\n%s', '\n'.join(params.result))

        # record all filenames as dependencies -- this will at least
        # partially make automatic invalidation possible
        for fn in params.record_dependencies:
            self.state.document.settings.record_dependencies.add(fn)

        result = parse_generated_content(self.state, params.result, documenter)
        return result
