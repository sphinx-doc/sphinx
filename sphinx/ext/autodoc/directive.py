from __future__ import annotations

from typing import TYPE_CHECKING

from docutils import nodes
from docutils.statemachine import StringList

from sphinx.ext.autodoc._directive_options import (
    _AutoDocumenterOptions,
    _process_documenter_options,
)
from sphinx.ext.autodoc._generate import _generate_directives
from sphinx.ext.autodoc.importer import _load_object_by_name
from sphinx.util import logging
from sphinx.util.docutils import SphinxDirective, switch_source_input
from sphinx.util.inspect import safe_getattr
from sphinx.util.parsing import nested_parse_to_nodes

if TYPE_CHECKING:
    from collections.abc import Callable, Sequence
    from typing import Any, NoReturn

    from docutils.nodes import Node
    from docutils.parsers.rst.states import RSTState


logger = logging.getLogger(__name__)


class _AutodocAttrGetter:
    """getattr() override for types such as Zope interfaces."""

    _attr_getters: Sequence[tuple[type, Callable[[Any, str, Any], Any]]]

    __slots__ = ('_attr_getters',)

    def __init__(
        self, attr_getters: dict[type, Callable[[Any, str, Any], Any]], /
    ) -> None:
        super().__setattr__('_attr_getters', tuple(attr_getters.items()))

    def __call__(self, obj: Any, name: str, *defargs: Any) -> Any:
        for typ, func in self._attr_getters:
            if isinstance(obj, typ):
                return func(obj, name, *defargs)

        return safe_getattr(obj, name, *defargs)

    def __repr__(self) -> str:
        return f'_AutodocAttrGetter({dict(self._attr_getters)!r})'

    def __setattr__(self, key: str, value: Any) -> NoReturn:
        msg = f'{self.__class__.__name__} is immutable'
        raise AttributeError(msg)

    def __delattr__(self, key: str) -> NoReturn:
        msg = f'{self.__class__.__name__} is immutable'
        raise AttributeError(msg)


class DummyOptionSpec(dict[str, 'Callable[[str], str]']):  # NoQA: FURB189
    """An option_spec allows any options."""

    def __bool__(self) -> bool:
        """Behaves like some options are defined."""
        return True

    def __getitem__(self, _key: str) -> Callable[[str], str]:
        return lambda x: x


def parse_generated_content(
    state: RSTState, content: StringList, titles_allowed: bool
) -> list[Node]:
    """Parse an item of content generated by Documenter."""
    with switch_source_input(state, content):
        if titles_allowed:
            return nested_parse_to_nodes(state, content)

        node = nodes.paragraph()
        # necessary so that the child nodes get the right source/line set
        node.document = state.document
        state.nested_parse(content, 0, node, match_titles=False)
        return node.children


class AutodocDirective(SphinxDirective):
    """A directive class for all autodoc directives. It works as a dispatcher of Documenters.

    It invokes a Documenter upon running. After the processing, it parses and returns
    the content generated by Documenter.
    """

    option_spec = DummyOptionSpec()
    has_content = True
    required_arguments = 1
    optional_arguments = 0
    final_argument_whitespace = True

    def run(self) -> list[Node]:
        reporter = self.state.document.reporter

        try:
            source, lineno = reporter.get_source_and_line(  # type: ignore[attr-defined]
                self.lineno
            )
        except AttributeError:
            source, lineno = (None, None)
        logger.debug('[autodoc] %s:%s: input:\n%s', source, lineno, self.block_text)

        registry = self.env._registry

        # look up target Documenter
        objtype = self.name[4:]  # strip prefix (auto-).
        doccls = registry.documenters[objtype]
        option_spec = doccls.option_spec
        titles_allowed = doccls.titles_allowed

        # process the options with the selected documenter's option_spec
        try:
            opts = _process_documenter_options(
                option_spec=option_spec,
                default_options=self.config.autodoc_default_options,
                options=self.options,
            )
            documenter_options = _AutoDocumenterOptions.from_directive_options(opts)
        except (KeyError, ValueError, TypeError) as exc:
            # an option is either unknown or has a wrong type
            logger.error(  # NoQA: TRY400
                'An option to %s is either unknown or has an invalid value: %s',
                self.name,
                exc,
                location=(self.env.current_document.docname, lineno),
            )
            return []
        documenter_options._tab_width = self.state.document.settings.tab_width

        # generate the output
        get_attr = _AutodocAttrGetter(registry.autodoc_attrgetters)
        name = self.arguments[0]
        env = self.env
        config = env.config
        current_document = env.current_document
        events = env.events

        props = _load_object_by_name(
            name=name,
            objtype=objtype,  # type: ignore[arg-type]
            mock_imports=config.autodoc_mock_imports,
            type_aliases=config.autodoc_type_aliases,
            current_document=current_document,
            config=config,
            env=env,
            events=events,
            get_attr=get_attr,
            options=documenter_options,
        )
        if props is None:
            return []

        record_dependencies: set[str] = set()
        result = StringList()
        _generate_directives(
            more_content=self.content,
            config=config,
            current_document=current_document,
            env=env,
            events=events,
            get_attr=get_attr,
            indent='',
            options=documenter_options,
            props=props,
            record_dependencies=record_dependencies,
            result=result,
        )
        if not result:
            return []

        logger.debug('[autodoc] output:\n%s', '\n'.join(result))

        # record all filenames as dependencies -- this will at least
        # partially make automatic invalidation possible
        for fn in record_dependencies:
            self.state.document.settings.record_dependencies.add(fn)

        return parse_generated_content(self.state, result, titles_allowed)
